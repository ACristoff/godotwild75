[gd_scene load_steps=56 format=3 uid="uid://c4og836lcexue"]

[ext_resource type="Script" path="res://Game/UI/lose_screen.gd" id="1_0xpn7"]
[ext_resource type="AudioStream" uid="uid://of2xqqxf14fl" path="res://Assets/Audio/Music/MM_Defeat.mp3" id="2_0fb0b"]
[ext_resource type="PackedScene" uid="uid://uxh57d4b5bja" path="res://Assets/Shaders/smog.tscn" id="3_j6ck3"]
[ext_resource type="PackedScene" uid="uid://bat17sfqaplx7" path="res://Assets/Shaders/sakuratree.tscn" id="4_012gl"]
[ext_resource type="Texture2D" uid="uid://bxg4ll16l8637" path="res://Assets/Environment/Objects/TrunkDark.png" id="5_03djw"]
[ext_resource type="Texture2D" uid="uid://b1fcx6qi402lv" path="res://Assets/Environment/Objects/LeavesDark.png" id="6_jkwrw"]
[ext_resource type="Texture2D" uid="uid://mc1lvwhbh4" path="res://Assets/Environment/GridTileMap/perspectiveground.png" id="7_815ak"]
[ext_resource type="Texture2D" uid="uid://6spl2drkii4x" path="res://Assets/UserInterface/Menu/Brush.png" id="8_gt4fc"]
[ext_resource type="FontFile" uid="uid://cidju740k3qx7" path="res://Assets/Fonts/nagayama_kai08.otf" id="9_bv743"]
[ext_resource type="Texture2D" uid="uid://bgpptpmtcs5ow" path="res://Assets/UserInterface/Gameplay/Shadow.png" id="10_8os06"]
[ext_resource type="Texture2D" uid="uid://bavno1c0lvi0s" path="res://Assets/Characters/Friendly/MikoDead.png" id="11_3ifbc"]
[ext_resource type="PackedScene" uid="uid://domnit2msh3jg" path="res://Assets/Shaders/god_ray.tscn" id="12_xu5bp"]
[ext_resource type="Theme" uid="uid://2kj2sgp8odd4" path="res://Assets/Themes/Buttons2.tres" id="15_jchd1"]
[ext_resource type="Texture2D" uid="uid://dtb7dx7u0jowt" path="res://Assets/UserInterface/Gameplay/GoldSelection.png" id="16_ned1f"]
[ext_resource type="Texture2D" uid="uid://cxv5b7d60qvm7" path="res://Assets/Effects/Particles/firelantern.png" id="17_4dbwd"]
[ext_resource type="Shader" path="res://Assets/Shaders/light.gdshader" id="18_cmpfd"]

[sub_resource type="Shader" id="Shader_42ys1"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix, unshaded;

uniform sampler2D SCREEN_TEXTURE : hint_screen_texture;
uniform float intensity : hint_range(0.0, 1.0) = 1.0;
uniform sampler2D noise_texture : hint_default_white;
uniform float use_custom_texture : hint_range(0.0, 1.0) = 0.0;
uniform float clouds_speed : hint_range(0.0, 20.0, 0.01) = 2.0;
uniform float clouds_direction : hint_range(-0.5, 0.5, 0.01) = 0.2;
uniform float clouds_scale : hint_range(0.0, 4.0, 0.01) = 1.0;
uniform float clouds_cutoff : hint_range(0.0, 1.0, 0.01) = 0.3;
uniform float clouds_fuzziness : hint_range(0.0, 2.0, 0.01) = 0.5;
uniform vec3 clouds_color : source_color = vec3(1.0, 1.0, 1.0);
uniform float edge_fade : hint_range(0.0, 1.0, 0.01) = 0.15;

// Separate float uniforms for box_position
uniform float box_position_x : hint_range(0.0, 1.0) = 0.5; // X position
uniform float box_position_y : hint_range(0.0, 1.0) = 0.5; // Y position
uniform float box_size : hint_range(0.0, 1.0) = 0.2; // Size of the box

uniform int PRIME_X = 501125221;
uniform int PRIME_Y = 1136930381;

float lerp(float a, float b, float t) {
    return a + t * (b - a);
}

float cubic_lerp(float a, float b, float c, float d, float t) {
    float p = d - c - (a - b);
    return t * t * t * p + t * t * (a - b - p) + t * (c - a) + b;
}

float ping_pong(float t) {
    t -= trunc(t * 0.5) * 2.0;
    return t < 1.0 ? t : 2.0 - t;
}

int hash(int seed, int x_primed, int y_primed) {
    return (seed ^ x_primed ^ y_primed) * 0x27d4eb2d;
}

float val_coord(int seed, int x_primed, int y_primed) {
    int hash = hash(seed, x_primed, y_primed);
    hash *= hash;
    hash ^= hash << 19;
    return float(hash) * (1.0 / 2147483648.0);
}

float single_value_cubic(int seed, float x, float y) {
    int x1 = int(floor(x));
    int y1 = int(floor(y));

    float xs = x - float(x1);
    float ys = y - float(y1);

    x1 *= PRIME_X;
    y1 *= PRIME_Y;
    int x0 = x1 - PRIME_X;
    int y0 = y1 - PRIME_Y;
    int x2 = x1 + PRIME_X;
    int y2 = y1 + PRIME_Y;
    int x3 = x1 + (PRIME_X << 1);
    int y3 = y1 + (PRIME_Y << 1);

    return cubic_lerp(
        cubic_lerp(val_coord(seed, x0, y0), val_coord(seed, x1, y0), val_coord(seed, x2, y0), val_coord(seed, x3, y0), xs),
        cubic_lerp(val_coord(seed, x0, y1), val_coord(seed, x1, y1), val_coord(seed, x2, y1), val_coord(seed, x3, y1), xs),
        cubic_lerp(val_coord(seed, x0, y2), val_coord(seed, x1, y2), val_coord(seed, x2, y2), val_coord(seed, x3, y2), xs),
        cubic_lerp(val_coord(seed, x0, y3), val_coord(seed, x1, y3), val_coord(seed, x2, y3), val_coord(seed, x3, y3), xs),
    ys) * (1.0 / (1.5 * 1.5));
}

const float FRACTAL_BOUNDING = 1.0 / 1.75;
const int OCTAVES = 5;
const float PING_PONG_STRENGTH = 2.0;
const float WEIGHTED_STRENGTH = 0.0;
const float GAIN = 0.5;
const float LACUNARITY = 2.0;

float gen_fractal_ping_pong(vec2 pos, int seed, float frequency) {
    float x = pos.x * frequency;
    float y = pos.y * frequency;
    float sum = 0.0;
    float amp = FRACTAL_BOUNDING;
    for (int i = 0; i < OCTAVES; i++) {
        float noise = ping_pong((single_value_cubic(seed++, x, y) + 1.0) * PING_PONG_STRENGTH);
        sum += (noise - 0.5) * 2.0 * amp;
        amp *= lerp(1.0, noise, WEIGHTED_STRENGTH);
        x *= LACUNARITY;
        y *= LACUNARITY;
        amp *= GAIN;
    }
    return sum * 0.5 + 0.5;
}

float calculate_edge_fade(vec2 uv) {
    vec2 fade = smoothstep(vec2(0.0), vec2(edge_fade), uv) *
                smoothstep(vec2(0.0), vec2(edge_fade), 1.0 - uv);
    return fade.x * fade.y;
}

vec4 overlay(vec4 base, vec4 blend) {
    vec4 limit = step(0.5, base);
    return mix(2.0 * base * blend, 1.0 - 2.0 * (1.0 - base) * (1.0 - blend), limit);
}

void fragment() {
    // BLENDING render_mode
    vec4 bg_color = texture(SCREEN_TEXTURE, SCREEN_UV);
    COLOR.rgb = mix(COLOR, overlay(bg_color, COLOR), intensity).rgb;

    // Get box position from separate floats
    vec2 box_position = vec2(box_position_x, box_position_y);
    float box_half_size = box_size * 0.5;

    // Calculate if the current pixel is inside the box (masking out clouds inside the box)
    bool inside_box = abs(UV.x - box_position.x) < box_half_size && abs(UV.y - box_position.y) < box_half_size;

    // Initialize cloud density variable
    float cloud_density = 0.0;

    if (inside_box) {
        // Set cloud density to 0 for pixels inside the box (this masks the clouds)
        cloud_density = 0.0;
    } else {
        // Cloud drawing logic outside the box
        vec2 base_uv = UV * clouds_scale;
        float time = TIME * clouds_speed * 0.01;
        float sin_x = sin(clouds_direction * PI * 2.0);
        float cos_y = cos(clouds_direction * PI * 2.0);
        vec2 clouds_movement = vec2(sin_x, cos_y) * time;

        if (use_custom_texture > 0.5) {
            cloud_density = texture(noise_texture, base_uv + clouds_movement).r;
        } else {
            float noise_top = gen_fractal_ping_pong((base_uv + clouds_movement), 0, 0.5);
            float noise_middle = gen_fractal_ping_pong((base_uv + clouds_movement * 0.89), 1, 0.75);
            float noise_bottom = gen_fractal_ping_pong((base_uv + clouds_movement * 0.79), 2, 1.0);

            float noise_bottom_smooth = smoothstep(clouds_cutoff, clouds_cutoff + clouds_fuzziness, noise_bottom);
            float noise_middle_smooth = smoothstep(clouds_cutoff, clouds_cutoff + clouds_fuzziness, noise_middle + noise_bottom_smooth * 0.2) * 1.1;
            float noise_top_smooth = smoothstep(clouds_cutoff, clouds_cutoff + clouds_fuzziness, noise_top + noise_middle_smooth * 0.4) * 1.2;

            cloud_density = clamp(noise_top_smooth + noise_middle_smooth + noise_bottom_smooth, 0.0, 1.0);
        }
    }

    // Calculate edge fade for smooth transition
    float edge_alpha = calculate_edge_fade(UV);
    COLOR = vec4(clouds_color, cloud_density * edge_alpha);
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_17wg2"]
resource_local_to_scene = true
shader = SubResource("Shader_42ys1")
shader_parameter/intensity = 1.0
shader_parameter/use_custom_texture = 0.0
shader_parameter/clouds_speed = 3.06
shader_parameter/clouds_direction = 0.28
shader_parameter/clouds_scale = 2.11
shader_parameter/clouds_cutoff = 0.5
shader_parameter/clouds_fuzziness = 0.0
shader_parameter/clouds_color = Color(1, 1, 1, 1)
shader_parameter/edge_fade = 0.18
shader_parameter/box_position_x = 0.5
shader_parameter/box_position_y = 0.5
shader_parameter/box_size = 0.0
shader_parameter/PRIME_X = 501125701
shader_parameter/PRIME_Y = 1136930381

[sub_resource type="Shader" id="Shader_qrock"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);

// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_ubmf0"]
resource_local_to_scene = true
shader = SubResource("Shader_qrock")
shader_parameter/speed = 1.0
shader_parameter/minStrength = 0.05
shader_parameter/maxStrength = 0.01
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = null
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0

[sub_resource type="Shader" id="Shader_fm0vi"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);

// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_ds20f"]
resource_local_to_scene = true
shader = SubResource("Shader_fm0vi")
shader_parameter/speed = 1.0
shader_parameter/minStrength = 0.05
shader_parameter/maxStrength = 0.01
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = null
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0

[sub_resource type="Shader" id="Shader_151ll"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);

// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_7lrs3"]
resource_local_to_scene = true
shader = SubResource("Shader_151ll")
shader_parameter/speed = 1.0
shader_parameter/minStrength = 0.05
shader_parameter/maxStrength = 0.01
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = null
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0

[sub_resource type="Shader" id="Shader_67a6c"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);

// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_ymxyi"]
resource_local_to_scene = true
shader = SubResource("Shader_67a6c")
shader_parameter/speed = 1.0
shader_parameter/minStrength = 0.05
shader_parameter/maxStrength = 0.01
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = null
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0

[sub_resource type="Shader" id="Shader_eyj15"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);

// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_cjgb1"]
resource_local_to_scene = true
shader = SubResource("Shader_eyj15")
shader_parameter/speed = 1.0
shader_parameter/minStrength = 0.05
shader_parameter/maxStrength = 0.01
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = null
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0

[sub_resource type="Shader" id="Shader_gpd5d"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);

// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_n4f76"]
resource_local_to_scene = true
shader = SubResource("Shader_gpd5d")
shader_parameter/speed = 1.0
shader_parameter/minStrength = 0.05
shader_parameter/maxStrength = 0.01
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = null
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0

[sub_resource type="Shader" id="Shader_jfudl"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);

// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_a0w6k"]
resource_local_to_scene = true
shader = SubResource("Shader_jfudl")
shader_parameter/speed = 1.0
shader_parameter/minStrength = 0.05
shader_parameter/maxStrength = 0.01
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = null
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0

[sub_resource type="Shader" id="Shader_b1b7v"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);

// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_jl3j0"]
resource_local_to_scene = true
shader = SubResource("Shader_b1b7v")
shader_parameter/speed = 1.0
shader_parameter/minStrength = 0.05
shader_parameter/maxStrength = 0.01
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = null
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0

[sub_resource type="Shader" id="Shader_hrqcx"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);

// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_sr043"]
resource_local_to_scene = true
shader = SubResource("Shader_hrqcx")
shader_parameter/speed = 1.0
shader_parameter/minStrength = 0.05
shader_parameter/maxStrength = 0.01
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = null
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0

[sub_resource type="Shader" id="Shader_1dnjn"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);

// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_ccvb7"]
resource_local_to_scene = true
shader = SubResource("Shader_1dnjn")
shader_parameter/speed = 1.0
shader_parameter/minStrength = 0.05
shader_parameter/maxStrength = 0.01
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = null
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0

[sub_resource type="Shader" id="Shader_awv5l"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);

// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_uchjy"]
resource_local_to_scene = true
shader = SubResource("Shader_awv5l")
shader_parameter/speed = 1.0
shader_parameter/minStrength = 0.05
shader_parameter/maxStrength = 0.01
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = null
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0

[sub_resource type="Shader" id="Shader_o64ca"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);

// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_6moe0"]
resource_local_to_scene = true
shader = SubResource("Shader_o64ca")
shader_parameter/speed = 1.0
shader_parameter/minStrength = 0.05
shader_parameter/maxStrength = 0.01
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = null
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0

[sub_resource type="Shader" id="Shader_kn2jw"]
resource_local_to_scene = true
code = "shader_type canvas_item;

uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;
uniform float angle = -0.3;
uniform float position = -0.2;
uniform float spread : hint_range(0.0, 1.0) = 0.5;
uniform float cutoff : hint_range(-1.0, 1.0) = 0.1;
uniform float falloff : hint_range(0.0, 1.0) = 0.2;
uniform float edge_fade : hint_range(0.0, 1.0) = 0.15;

uniform float speed = 1.0;
uniform float ray1_density = 8.0;
uniform float ray2_density = 30.0;
uniform float ray2_intensity : hint_range(0.0, 1.0) = 0.3;

uniform vec4 color : source_color = vec4(1.0, 0.9, 0.65, 0.8);

uniform bool hdr = false;
uniform float seed = 5.0;

// Random and noise functions from Book of Shader's chapter on Noise.
float random(vec2 _uv) {
    return fract(sin(dot(_uv.xy,
                         vec2(12.9898, 78.233))) *
        43758.5453123);
}

float noise (in vec2 uv) {
    vec2 i = floor(uv);
    vec2 f = fract(uv);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));


    // Smooth Interpolation

    // Cubic Hermine Curve. Same as SmoothStep()
    vec2 u = f * f * (3.0-2.0 * f);

    // Mix 4 coorners percentages
    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

mat2 rotate(float _angle){
    return mat2(vec2(cos(_angle), -sin(_angle)),
                vec2(sin(_angle), cos(_angle)));
}

vec4 screen(vec4 base, vec4 blend){
	return 1.0 - (1.0 - base) * (1.0 - blend);
}

void fragment()
{

	// Rotate, skew and move the UVs
	vec2 transformed_uv = ( rotate(angle) * (UV - position) )  / ( (UV.y + spread) - (UV.y * spread) );

	// Animate the ray according the the new transformed UVs
	vec2 ray1 = vec2(transformed_uv.x * ray1_density + sin(TIME * 0.1 * speed) * (ray1_density * 0.2) + seed, 1.0);
	vec2 ray2 = vec2(transformed_uv.x * ray2_density + sin(TIME * 0.2 * speed) * (ray1_density * 0.2) + seed, 1.0);

	// Cut off the ray's edges
	float cut = step(cutoff, transformed_uv.x) * step(cutoff, 1.0 - transformed_uv.x);
	ray1 *= cut;
	ray2 *= cut;

	// Apply the noise pattern (i.e. create the rays)
	float rays;

	if (hdr){
		// This is not really HDR, but check this to not clamp the two merged rays making
		// their values go over 1.0. Can make for some nice effect
		rays = noise(ray1) + (noise(ray2) * ray2_intensity);
	}
	else{
		 rays = clamp(noise(ray1) + (noise(ray2) * ray2_intensity), 0., 1.);
	}

	// Fade out edges
	rays *= smoothstep(0.0, falloff, (1.0 - UV.y)); // Bottom
	rays *= smoothstep(0.0 + cutoff, edge_fade + cutoff, transformed_uv.x); // Left
	rays *= smoothstep(0.0 + cutoff, edge_fade + cutoff, 1.0 - transformed_uv.x); // Right

	// Color to the rays
	vec3 shine = vec3(rays) * color.rgb;

	// Try different blending modes for a nicer effect. \"Screen\" is included in the code,
	// but take a look at https://godotshaders.com/snippet/blending-modes/ for more.
	// With \"Screen\" blend mode:
	shine = screen(texture(SCREEN_TEXTURE, SCREEN_UV), vec4(color)).rgb;

	COLOR = vec4(shine, rays * color.a);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_wrouy"]
resource_local_to_scene = true
shader = SubResource("Shader_kn2jw")
shader_parameter/angle = -0.3
shader_parameter/position = -0.2
shader_parameter/spread = 0.319
shader_parameter/cutoff = 0.206
shader_parameter/falloff = 0.689
shader_parameter/edge_fade = 0.203
shader_parameter/speed = 1.0
shader_parameter/ray1_density = 8.0
shader_parameter/ray2_density = 30.0
shader_parameter/ray2_intensity = 0.311
shader_parameter/color = Color(1, 0.984, 0.76, 0.8)
shader_parameter/hdr = false
shader_parameter/seed = 5.0

[sub_resource type="Shader" id="Shader_5xd5x"]
resource_local_to_scene = true
code = "shader_type canvas_item;
render_mode blend_mix;

// Wind settings.
uniform float speed = 1.0;
uniform float minStrength : hint_range(0.0, 1.0) = 0.05;
uniform float maxStrength : hint_range(0.0, 1.0) = 0.01;
uniform float strengthScale = 100.0;
uniform float interval = 3.5;
uniform float detail = 1.0;
uniform float distortion : hint_range(0.0, 1.0);
uniform float heightOffset : hint_range(0.0, 1.0);


// With the offset value, you can if you want different moves for each asset. Just put a random value (1, 2, 3) in the editor. Don't forget to mark the material as unique if you use this
uniform float offset = 0; 


float getWind(vec2 vertex, vec2 uv, float time){
    float diff = pow(maxStrength - minStrength, 2.0);
    float strength = clamp(minStrength + diff + sin(time / interval) * diff, minStrength, maxStrength) * strengthScale;
    float wind = (sin(time) + cos(time * detail)) * strength * max(0.0, (1.0-uv.y) - heightOffset);
    
    return wind; 
}

void vertex() {
    vec4 pos = MODEL_MATRIX * vec4(0.0, 0.0, 0.0, 1.0);
    float time = TIME * speed + offset;
    //float time = TIME * speed + pos.x * pos.y  ; not working when moving...
    VERTEX.x += getWind(VERTEX.xy, UV, time);
}
uniform int strength: hint_range(1, 512) = 2;

vec4 blur_size(sampler2D tex,vec2 fragCoord, vec2 pixelSize) {
    
    vec4 color = vec4(0.,0.,0.,0.);
    float strengthFloat = float(strength);	

    vec2 pixel = fragCoord/pixelSize;
    int x_min = max(int(pixel.x-strengthFloat), 0);
    int x_max = min(int(pixel.x+strengthFloat), int(1./pixelSize.x));
    int y_min = max(int(pixel.y-strengthFloat), 0);
    int y_max = min(int(pixel.y+strengthFloat), int(1./pixelSize.y));

    int count =0;

    // Sum the pixels colors
    for(int x=x_min; x <= x_max; x++) {
        for(int y = y_min; y <= y_max; y++) {           
            color += texture(tex, vec2(float(x), float(y)) * pixelSize);
            count++;
        }
    }
    
    // Divide the color by the number of colors you summed up
    color /= float(count);
    
    return color;
}

void fragment() {	
    COLOR = blur_size(TEXTURE,UV,TEXTURE_PIXEL_SIZE);
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_dt37m"]
resource_local_to_scene = true
shader = SubResource("Shader_5xd5x")
shader_parameter/speed = 2.0
shader_parameter/minStrength = 0.018
shader_parameter/maxStrength = 0.0
shader_parameter/strengthScale = 100.0
shader_parameter/interval = 3.5
shader_parameter/detail = 1.0
shader_parameter/distortion = 0.0
shader_parameter/heightOffset = null
shader_parameter/offset = 0.0
shader_parameter/strength = 2

[sub_resource type="Gradient" id="Gradient_ic5mj"]
colors = PackedColorArray(0.2, 0, 0.00333328, 1, 1, 0.930333, 0.78, 1)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_fbx85"]
gradient = SubResource("Gradient_ic5mj")

[sub_resource type="Environment" id="Environment_xpuvo"]
background_mode = 3
adjustment_enabled = true
adjustment_color_correction = SubResource("GradientTexture1D_fbx85")

[sub_resource type="Animation" id="Animation_2xval"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:frame")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [0]
}

[sub_resource type="Animation" id="Animation_5f72u"]
resource_name = "fire"
length = 0.5
loop_mode = 1
step = 0.1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:frame")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.1, 0.2, 0.3, 0.4, 0.5),
"transitions": PackedFloat32Array(1, 1, 1, 1, 1, 1),
"update": 1,
"values": [0, 1, 2, 3, 4, 4]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_7oo2u"]
_data = {
"RESET": SubResource("Animation_2xval"),
"fire": SubResource("Animation_5f72u")
}

[sub_resource type="Gradient" id="Gradient_oo5hb"]
offsets = PackedFloat32Array(0, 0.462121)
colors = PackedColorArray(1, 1, 1, 1, 1, 1, 1, 0)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_n3s1s"]
gradient = SubResource("Gradient_oo5hb")
fill = 1
fill_from = Vector2(0.459184, 0.494898)
fill_to = Vector2(1, 1)

[sub_resource type="ShaderMaterial" id="ShaderMaterial_sv5jg"]
shader = ExtResource("18_cmpfd")
shader_parameter/light_color = Vector3(255, 255, 255)
shader_parameter/brightness = 0.5
shader_parameter/attenuation_strength = 0.5
shader_parameter/intensity = 1.0
shader_parameter/max_brightness = 1.0
shader_parameter/light_texture = SubResource("GradientTexture2D_n3s1s")

[node name="Lose" type="Node2D"]
script = ExtResource("1_0xpn7")

[node name="AudioStreamPlayer2D" type="AudioStreamPlayer2D" parent="."]
stream = ExtResource("2_0fb0b")

[node name="ColorRect3" type="ColorRect" parent="."]
offset_left = -641.0
offset_top = -443.0
offset_right = 2075.0
offset_bottom = 1056.0
mouse_filter = 2
color = Color(1, 0.55, 0, 1)

[node name="smog" parent="." instance=ExtResource("3_j6ck3")]
material = SubResource("ShaderMaterial_17wg2")

[node name="ColorRect" parent="smog" index="0"]
offset_left = -550.0
offset_top = -480.0
offset_right = 1825.0
offset_bottom = 331.0

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -42.0
offset_top = 521.0
offset_right = 1612.0
offset_bottom = 826.0
mouse_filter = 2
color = Color(0.0748, 0.20548, 0.22, 1)

[node name="ColorRect2" type="ColorRect" parent="."]
offset_left = -42.0
offset_top = 221.0
offset_right = 1612.0
offset_bottom = 526.0
mouse_filter = 2
color = Color(0.0628334, 0, 0.13, 1)

[node name="TreesBG" type="Node2D" parent="."]
position = Vector2(0, 70)

[node name="Trunk9" parent="TreesBG" instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_ubmf0")
position = Vector2(406, 283)
scale = Vector2(3, 4)
texture = ExtResource("5_03djw")

[node name="Leaves2" parent="TreesBG/Trunk9" index="0"]
texture = ExtResource("6_jkwrw")

[node name="Trunk10" parent="TreesBG" instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_ds20f")
position = Vector2(916, 352)
scale = Vector2(3, 4)
texture = ExtResource("5_03djw")

[node name="Leaves2" parent="TreesBG/Trunk10" index="0"]
texture = ExtResource("6_jkwrw")

[node name="Trunk11" parent="TreesBG" instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_7lrs3")
position = Vector2(23, 344)
scale = Vector2(3, 4)
texture = ExtResource("5_03djw")

[node name="Leaves2" parent="TreesBG/Trunk11" index="0"]
texture = ExtResource("6_jkwrw")

[node name="Trunk12" parent="TreesBG" instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_ymxyi")
position = Vector2(1246, 305)
scale = Vector2(3, 4)
texture = ExtResource("5_03djw")

[node name="Leaves2" parent="TreesBG/Trunk12" index="0"]
texture = ExtResource("6_jkwrw")

[node name="Trunk4" parent="TreesBG" instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_cjgb1")
position = Vector2(253, 313)
scale = Vector2(3, 3)

[node name="Trunk5" parent="TreesBG" instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_n4f76")
position = Vector2(332, 294)
scale = Vector2(3, 3)

[node name="Trunk6" parent="TreesBG" instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_a0w6k")
position = Vector2(560, 271)
scale = Vector2(3, 3)

[node name="Trunk7" parent="TreesBG" instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_jl3j0")
position = Vector2(834, 273)
scale = Vector2(3, 3)

[node name="Trunk8" parent="TreesBG" instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_sr043")
position = Vector2(1059, 267)
scale = Vector2(3, 3)

[node name="Trunk" parent="TreesBG" instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_ccvb7")
position = Vector2(122, 306)

[node name="Trunk2" parent="TreesBG" instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_uchjy")
position = Vector2(1423, 197)

[node name="Trunk3" parent="TreesBG" instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_6moe0")
position = Vector2(1289, 304)
scale = Vector2(3, 3)

[node name="Perspectiveground" type="Sprite2D" parent="."]
position = Vector2(682, 466)
scale = Vector2(2, 2)
texture = ExtResource("7_815ak")

[node name="Brush" type="Sprite2D" parent="."]
self_modulate = Color(0.627451, 0.141176, 0.141176, 1)
position = Vector2(635, 210)
texture = ExtResource("8_gt4fc")

[node name="Label" type="Label" parent="Brush"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -512.0
offset_top = -147.0
offset_right = -512.0
offset_bottom = -147.0
grow_horizontal = 2
grow_vertical = 2
theme_override_fonts/font = ExtResource("9_bv743")
theme_override_font_sizes/font_size = 200
text = "Defeat"
horizontal_alignment = 1
vertical_alignment = 1

[node name="Node2D" type="Node2D" parent="."]
position = Vector2(596, 466)
scale = Vector2(4, 4)

[node name="Shadow" type="Sprite2D" parent="Node2D"]
modulate = Color(0, 0, 0, 0.254902)
position = Vector2(15.625, 45.125)
scale = Vector2(0.585938, 0.585938)
texture = ExtResource("10_8os06")

[node name="MikoFlex" type="Sprite2D" parent="Node2D"]
position = Vector2(14.25, 37.75)
texture = ExtResource("11_3ifbc")

[node name="Node2D2" parent="." instance=ExtResource("12_xu5bp")]
material = SubResource("ShaderMaterial_wrouy")
position = Vector2(423, 20)

[node name="ColorRect" parent="Node2D2" index="0"]
offset_left = -246.0
offset_top = -292.0
offset_right = 616.0
offset_bottom = 597.0

[node name="Trunk2" parent="." instance=ExtResource("4_012gl")]
material = SubResource("ShaderMaterial_dt37m")
position = Vector2(1547, 154)
scale = Vector2(6, 6)
texture = ExtResource("5_03djw")

[node name="Leaves2" parent="Trunk2" index="0"]
texture = ExtResource("6_jkwrw")

[node name="Onward2" type="Button" parent="."]
z_index = 1
offset_left = 829.0
offset_top = 436.0
offset_right = 1173.0
offset_bottom = 514.0
theme = ExtResource("15_jchd1")
theme_override_colors/font_color = Color(1, 1, 1, 1)
theme_override_font_sizes/font_size = 50
text = "Previous Level"

[node name="Retry2" type="Button" parent="."]
offset_left = 135.0
offset_top = 426.0
offset_right = 469.0
offset_bottom = 504.0
theme = ExtResource("15_jchd1")
theme_override_colors/font_color = Color(1, 1, 1, 1)
theme_override_font_sizes/font_size = 50
text = "Retry?"

[node name="GoldSelection" type="Sprite2D" parent="."]
position = Vector2(996, 475)
scale = Vector2(3, 2)
texture = ExtResource("16_ned1f")

[node name="GoldSelection2" type="Sprite2D" parent="."]
position = Vector2(302, 465)
scale = Vector2(3, 2)
texture = ExtResource("16_ned1f")

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_xpuvo")

[node name="Firelantern" type="Sprite2D" parent="."]
position = Vector2(659, 504)
scale = Vector2(4, 4)
texture = ExtResource("17_4dbwd")
hframes = 5

[node name="AnimationPlayer" type="AnimationPlayer" parent="Firelantern"]
libraries = {
"": SubResource("AnimationLibrary_7oo2u")
}
autoplay = "fire"
speed_scale = 0.5

[node name="ColorRect" type="ColorRect" parent="Firelantern"]
material = SubResource("ShaderMaterial_sv5jg")
offset_left = -19.0
offset_top = -19.5
offset_right = 21.0
offset_bottom = 20.5

[connection signal="pressed" from="Onward2" to="." method="_on_onward_2_pressed"]
[connection signal="pressed" from="Retry2" to="." method="_on_retry_pressed"]

[editable path="smog"]
[editable path="TreesBG/Trunk9"]
[editable path="TreesBG/Trunk10"]
[editable path="TreesBG/Trunk11"]
[editable path="TreesBG/Trunk12"]
[editable path="Node2D2"]
[editable path="Trunk2"]
